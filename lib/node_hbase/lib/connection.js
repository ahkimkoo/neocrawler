// Generated by CoffeeScript 1.8.0
(function() {
  var ByteBuffer, Call, ClientService, Connection, ConnectionHeader, DataInputStream, DataOutputBuffer, DataOutputStream, EventEmitter, GetRequest, ProtoBuf, RequestHeader, ResponseHeader, Service, builder, connectionId, debug, hconstants, net, proto, rpcBuilder, rpcProto, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  debug = (require('debug'))('hbase-connection');

  net = require('net');

  hconstants = require('./hconstants');

  Call = require('./call');

  EventEmitter = require('events').EventEmitter;

  DataInputStream = require('./data-input-stream');

  _ref = require('./output-buffer'), DataOutputStream = _ref.DataOutputStream, DataOutputBuffer = _ref.DataOutputBuffer;

  ProtoBuf = require('protobufjs');

  ByteBuffer = require('bytebuffer');

  builder = ProtoBuf.loadProtoFile("" + __dirname + "/../proto/Client.proto");

  rpcBuilder = ProtoBuf.loadProtoFile("" + __dirname + "/../proto/RPC.proto");

  proto = builder.build();

  rpcProto = rpcBuilder.build();

  ClientService = proto.ClientService, GetRequest = proto.GetRequest;

  ConnectionHeader = rpcProto.ConnectionHeader, RequestHeader = rpcProto.RequestHeader, ResponseHeader = rpcProto.ResponseHeader;

  connectionId = 0;

  module.exports = Connection = (function(_super) {
    __extends(Connection, _super);

    function Connection(options) {
      this._handleError = __bind(this._handleError, this);
      this._handleClose = __bind(this._handleClose, this);
      this.setupConnection = __bind(this.setupConnection, this);
      this.writeHead = __bind(this.writeHead, this);
      this.processMessages = __bind(this.processMessages, this);
      this.setupIOStreams = __bind(this.setupIOStreams, this);
      this.id = connectionId++;
      this.callId = 1;
      this.calls = {};
      this.header = null;
      this.socket = null;
      this.tcpNoDelay = false;
      this.tcpKeepAlive = true;
      this.address = {
        host: options.host,
        port: options.port
      };
      this.name = "connection(" + this.address.host + ":" + this.address.port + ") id: " + this.id;
      this._connected = false;
      this._socketError = null;
      this._callNums = 0;
      this._callTimeout = options.callTimeout;
      this.setupIOStreams();
    }

    Connection.prototype.setupIOStreams = function() {
      debug("connecting to " + this.name);
      this.setupConnection();
      this["in"] = new DataInputStream(this.socket);
      this.out = new DataOutputStream(this.socket);
      this["in"].on('messages', this.processMessages);
      return this.socket.on('connect', (function(_this) {
        return function() {
          var ch, header, impl;
          debug("connected to " + _this.name);
          _this.writeHead();
          ch = new ConnectionHeader({
            serviceName: "ClientService"
          });
          header = ch.encode().toBuffer();
          _this.out.writeInt(header.length);
          _this.out.write(header);
          _this._connected = true;
          impl = function(method, req, done) {
            var reflect, reqHeader, reqHeaderBuffer;
            reflect = builder.lookup(method);
            reqHeader = new RequestHeader({
              callId: _this.callId++,
              requestParam: true,
              methodName: reflect.name
            });
            reqHeaderBuffer = reqHeader.toBuffer();
            _this.out.writeDelimitedBuffers(reqHeaderBuffer, req.toBuffer());
            return _this.calls[reqHeader.callId] = new Call(reflect.resolvedResponseType.clazz, reqHeader, _this._callTimeout, done);
          };
          _this.rpc = new ClientService(impl);
          return _this.emit('connect');
        };
      })(this));
    };

    Connection.prototype.processMessages = function(messages) {
      var call, header;
      header = ResponseHeader.decode(messages[0]);
      if (!(call = this.calls[header.callId])) {
        debug("Invalid callId " + header.callId);
        return;
      }
      if (header.exception) {
        return call.complete(header.exception);
      }
      return call.complete(null, call.responseClass.decode(messages[1]));
    };

    Connection.prototype.writeHead = function() {
      var b1, b2;
      b1 = new Buffer(1);
      b1.writeUInt8(0, 0);
      b2 = new Buffer([1]);
      b2.writeUInt8(80, 0);
      return this.out.write(Buffer.concat([hconstants.HEADER, b1, b2]));
    };

    Connection.prototype.setupConnection = function() {
      var ioFailures, timeoutFailures;
      ioFailures = 0;
      timeoutFailures = 0;
      this.socket = net.connect(this.address);
      this.socket.setNoDelay(this.tcpNoDelay);
      this.socket.setKeepAlive(this.tcpKeepAlive);
      this.socket.on("timeout", this._handleTimeout);
      this.socket.on("close", this._handleClose);
      return this.socket.on("error", this._handleError);
    };

    Connection.prototype._handleClose = function() {
      this.closed = true;
      this.emit('close');
      return debug("_handleClose " + (JSON.stringify(arguments)));
    };

    Connection.prototype._handleError = function(err) {
      this._handleClose();
      return debug("_handleError " + (JSON.stringify(arguments)));
    };

    Connection.prototype._handleTimeout = function() {
      return debug("_handleTimeout " + (JSON.stringify(arguments)));
    };

    return Connection;

  })(EventEmitter);

  Service = (function() {
    function Service(service, impl) {
      var client, r;
      r = builder.lookup(service);
      client = new r.clazz(impl);
      r.children.forEach((function(_this) {
        return function(child) {
          return _this[child.name] = function(req, done) {
            var clazz;
            clazz = child.resolvedRequestType.clazz;
            if (!(req instanceof clazz)) {
              req = new clazz(req);
            }
            return client[child.name].call(client, req, done);
          };
        };
      })(this));
    }

    return Service;

  })();

  ClientService = (function(_super) {
    __extends(ClientService, _super);

    function ClientService(impl) {
      ClientService.__super__.constructor.call(this, 'ClientService', impl);
    }

    return ClientService;

  })(Service);

}).call(this);
